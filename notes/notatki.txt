wyklad 1 ---

wyklad 2 ---
(+) :: Num a => a -> a -> a
(.) :: (b -> c) -> (a -> b) -> a -> c - zlozenie funkcji
repeat – tworzy nieskończona listę powtarzając podany
argument
cycle – tworzy nieskończona listę powtarzając podaną listę
elem <obiekt> <lista> – sprawdza, czy obiekt jest na liście
filter <warunek> <lista> – zwraca podlistę elementów spełniających warunek
Eq,Num,Show
wyklad 3 ---

wyklad 4 ---

wyklad 5 ---
map :: (a -> b) -> [a] -> [b]
przyjmuje funkcję f oraz listę (x1, . . . , xn) i zwraca listę
(f (x1), . . . , f (xn)).

filter :: (a -> Bool) -> [a] -> [a]
filter (\x->x `mod` 3 == 1) [1..10] --wklejam to dla skladni

Przydatną funkcją w sytuacji powyżej może być takeWhile, która
pobiera elementy z listy, póki spełniają podany warunek.
Przykładowo:
takeWhile (<10) [1..]
poprawnie zwróci skończoną listę
[1,2,3,4,5,6,7,8,9]
Analogiczna funkcja dropWhile działa podobnie, jednak ignoruje
elementy zamiast je pobierać, na przykład
dropWhile (<5) [1..10]
zwraca
[5,6,7,8,9,10]

Funkcja concatMap działa podobnie do map, jednak przyjmuje listę
list, po zastosowaniu na każdej z nich podanej funkcji scala wyniki
w jedną listę. Przykładowo:
concatMap (take 2) ["Ala","ma","kota"]
zwraca
"Almako"

iterate :: (a -> a) -> a -> [a]
przyjmuje funkcję f oraz element x, na którym można  wywołać
funkcję f i zwraca nieskończoną listę (x, f (x), f (f (x)), . . .).

zip :: [a] -> [b] -> [(a, b)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]


wyklad 6 ---

foldl - (. . .((x ◦ x1) ◦ x2) ◦ . . .) ◦ xn.
foldr - x1 ◦ (x2 ◦ . . . ◦ (xn−1 ◦ (xn ◦ x)). . .).

wyklad 7 ---

wyklad 8 ---

bezpunktowe ---



List comprehension w Haskellu to składnia, która pozwala na tworzenie nowych list w zwięzły sposób, stosując logikę filtrowania, mapowania lub warunkową do elementów istniejącej listy. Umożliwia ona generowanie list bez jawnej rekurencji, co czyni kod bardziej czytelnym i efektywnym. 
Jak to działa?
Struktura: List comprehension w Haskellu przyjmuje formę [<wyrażenie> | <zmienna> <- <lista>, <warunek>].
Działanie:
<-: Określa generator, który przypisuje poszczególne elementy z lista do zmienna.
|: Oddziela generator(y) od reszty wyrażenia.
warunek: Opcjonalna część, która filtruje elementy. Tylko te, które spełniają warunek, są przetwarzane dalej.
<wyrażenie>: Określa, co ma być wynikiem dla każdego elementu, który przeszedł przez filtr. Może to być wartość zmienna lub transformacja tej wartości. 
Przykład
Aby stworzyć listę kwadratów liczb parzystych z zakresu od 1 do 10:
Zapis: [x*x | x <- [1..10], x mod 2 == 0]
Wyjaśnienie:
x <- [1..10]: Bierzemy kolejne liczby z listy [1, 2, 3, ..., 10] i przypisujemy je do x.
x mod 2 == 0: Sprawdzamy, czy x jest liczbą parzystą.
x*x: Jeśli warunek jest spełniony, obliczamy kwadrat x.

